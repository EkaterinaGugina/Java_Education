Пусть требуется найти количество способов получить число b из числа a с помощью двух операций +k_1 или *k_2.

Идея решения без рекурсии:
1. Проверить, решаема (возможна) ли данная задача для данных чисел, проверяем условие (b % k_2 == a), или ((b - a) % k_1 == 0)

2. Если условия выполнены, создаем массив пар [числo, true/false] длиной N = (b / k_1), первые элементы пар заполняем циклом по N числами (b - k_1*N), последним элементом будет a. Это вершины графа. Второе число в паре - заполнять будем по мере прохождениия вершин. Пока они заполнены "false".

3. Далее реализуем алгоритм поиска количества путей от начала до конца в ориентированном графе: например, такой

 если P(v) — число путей от вершины s до вершины v. Тогда P(v) зависит только от вершин, ребра из которых входят в v. Тогда P(v)=∑cP(c) таких c, что есть ребро из c в v. Мы свели нашу задачу к меньшим подзадачам, причем мы также знаем, что P(s)=1. Э


Пусть s — стартовая вершина, а t — конечная, для нее и посчитаем ответ. Будем поддерживать массив d, где d[v] — число путей из вершины s до вершины v и массив w, где w[v]=true, если ответ для вершины v уже посчитан, и w[v]=false в противном случае. Изначально w[i]=false для всех вершин i, кроме s, а d[s]=1. Функция count(v) будет возвращать ответ для вершины v. Удобнее всего это реализовать в виде рекурсивной функции с запоминанием. В этом случае значения массива d будут вычисляться по мере необходимости и не будут считаться лишний раз:

count(v)= d[v], если w[v]=true; и

count(v) = ∑count(c),  если w[v]=false (c такое, что ребро cv ∈ E)

Псевдокод:

count(g, v)
    if w[v]
        return d[v]
    else
        sum = 0
        w[v] = true
        for c in g[v]
            sum += count(g, c)
        d[v] = sum
        return sum

countPaths(g, s, t)
    d[s] = 1
    w[s] = true
    answer = count(t)
    return answer
Значение функции count(v) считается для каждой вершины один раз, а внутри нее рассматриваются все такие ребра {e | end(e)=v}. Всего таких ребер для всех вершин в графе O(E), следовательно, время работы алгоритма в худшем случае оценивается как O(V+E), где V — число вершин графа, E — число ребер.